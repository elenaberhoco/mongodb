---
jupytext:
  cell_metadata_filter: -all
  formats: md:myst
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.12
    jupytext_version: 1.9.1
kernelspec:
  display_name: IMongo
  language: ''
  name: imongo
---

# Premi√®res requ√™tes en MongoDB

Dans un **syst√®me de base de donn√©es relationnelles**,les donn√©es sont stock√©es par ligne *(appel√©es n-uplets)* dans des tables *(√©galement appel√©es relations)*. Le mod√®le de donn√©es relationnel est un mod√®le tr√®s structur√©, comportant des attributs typ√©s et des contraintes d'int√©grit√© *(comme par exemple l'unicit√© des valeurs de la cl√© primaire)*. Il est n√©cessaire de faire des jointures sur plusieurs tables afin de tirer des informations pertinentes de la base.

**Dans MongoDB, les donn√©es sont mod√©lis√©es sous forme de document sous un style JSON.** On ne parle plus de tables, ni d'enregistrements mais de collections et de documents. Ce syst√®me de gestion de donn√©es nous √©vite de faire des jointures de tables car toutes les informations n√©cessaires sont stock√©es dans un m√™me document.

Tout document appartient √† une collection et a un champ appel√© "_id" qui identifie le document dans la base de donn√©es. Prenons Voici un exemple de document : 

```javascript
{
    "_id" : ObjectId("56011920de43611b917d773d"),
    "nom" : "Paul",
    "notes" : [ 
        10.0, 
        12.0
    ],
    "sexe" : "M"
}
```

> Dans ce chapitre, nous √©tudierons **comment filtrer les donn√©es d'une base de donn√©es MongoDB avec la fonction find**. Ensuite nous regarderons comment effectuer des requ√™tes plus complexes, **impliquant des op√©rateurs de comparaison**. Quelques **m√©thodes utiles** pour des requ√™tes en MongoDB sont donn√©es √† la fin de ce chapitre.

Auteurs/trices : **Julie FRANCOISE, Manon MAHEO et Valentin PENISSON**

---

## Requ√™tes d'interrogation et de filtrage des donn√©es : la fonction `find`

Pour r√©cup√©rer des documents stock√©s dans une collection, il est n√©cessaire d'utiliser la fonction find.
 
 ```{admonition} Remarque
Toute commande sur une collection intitul√©e collectionName utilise le pr√©fixe db : "db.collectionName". Il suffit d‚Äôy associer la fonction souhait√©e pour avoir un r√©sultat. 

En l'occurence, ici la synthaxe de donn√©es d'interrogation MongoDB est db.collectionName.find().
```

En MongoDB, il existe deux types de requ√™tes simples, retournant respectivement **toutes les occurences d'une collection** ou **seulement la premi√®re**. 

````{panels}

Retourner toutes les occurences 
d'une collection avec find()
^^^
```javascript
 db.collectionName.find()
 db.collectionName.find({}) 
```

---

Retourner uniquement la premi√®re occurence
de la liste de r√©sultats avec findOne()
^^^
```javascript
db.collectionName.findOne()
db.collectionName.findOne({})
```

````

> √Ä noter : Dans les deuxi√®mes propositions, on a des accolades entre les parenth√®ses de la fonction. Ces accolades correspondent au *document masque*. Elles sont vides ce qui indique que nous ne posons pas de condition sur les documents √† retourner. 

Si l‚Äôon souhaite fixer des contraintes sur les documents √† retourner, il suffit de passer en argument d‚Äôune de ces fonctions un document masque contenant les valeurs souhait√©es. Par exemple, la requ√™te suivante retourne tous les documents ayant un champ "x" dont la valeur est "y".

```javascript
db.nomDeLaCollection.find({"x":"y"})
```

Prenons comme exemple la base de donn√©es NYfood.   

````{tabbed} Syntaxe

```mongoDB
db.nomDeLaCollection.find({"x":"y"})
```
````
 
````{tabbed} Exemple sur la base de donn√©es NYfood

```mongoDB
db.NYfood.find({"cuisine":"Bakery"})
```

````

Projection

La projection permet de s√©lectionner les informations √† renvoyer. Si, par exemple, je m‚Äôint√©resse uniquement au titre du film, √† son ann√©e de sortie et aux noms des acteurs, je vais limiter les informations retourn√©es en pr√©cisant les champs souhait√©s dans un document JSON (toujours ce fameux JSON). Et, √©galement passer ce document comme deuxi√®me argument de ma recherche find.

```{admonition} Embellissez les r√©sultats de la fonction find ! 
:class: tip

Les r√©sultats de la fonction find() peuvent appara√Ætre d√©sorganis√©s. MongoDB fournit pretty() qui affiche les r√©sultats sous une forme plus lisible. La synthaxe est la suivante : collectionName.find().pretty() üòâ
```

Pour plus de renseignements sur la **fonction find()**, consultez la documentation MongoDB [disponible ici](https://docs.mongodb.com/manual/reference/method/db.collection.find/).

---

## Requ√™tes plus complexes en utilisant des op√©rateurs

Les op√©rateurs se s√©parent en deux grandes parties : les **op√©rateurs de comparaison** et les **op√©rateurs logiques**.

### Op√©rateurs de comparaison

L'op√©rateur de comparaison permet de comparer deux √©lements entre eux. Le tableau suivant l'ensemble des operateurs de comparaison : 

| Op√©rateur logique 	| Mot cl√© en MongoDB 	|
|-	|-	|
| = 	| $eq 	|
| < 	| $lt 	|
| > 	| $gt 	|
| ‚â§ 	| $lte 	|
| ‚â• 	| $gte 	|
| ‚àà 	| $in 	|
| ‚àâ 	| $nin 	|
| n√©gation 	| $not 	|
| cl√© existante 	| $exists 	|
| \|.\| 	| $size 	|

Les op√©rateurs `$eq`, `$lt`, `$gt`, `$lte`, `$gte` s'ulisent de la m√™me fa√ßon en MongoDB. Ces op√©rateurs comparent la valeur d'une variable √† une valeur fixe (nombre, bool√©en, chaine de caract√®res...).

````{panels}

MongoDB
^^^
```javascript
db.t.find(
    {"a": {$gte : 1}
    }
)
```

---

SQL
^^^
```sql
SELECT *
FROM t
WHERE a >= 1 
```

````

Les op√©rateurs `$in` et `$nin` s'ulisent de la m√™me fa√ßon en MongoDB. Ces op√©rateurs teste l'existence de la valeur d'une variable dans une liste. Sa fa√ßon de l'utiliser en MongoDB est la suivante : 

````{panels}

MongoDB
^^^
```javascript
db.t.find(
    {"a": { $in: ["chaine1", "chaine2"] }
    }
)
```

---

SQL
^^^
```sql
SELECT *
FROM t
WHERE a IN ("chaine1", "chaine2")
```

````

L'op√©rateur `$exists` v√©rifie l'existence d'une cl√© dans un document. Sa syntaxe en MongoDB est : 

MongoDB
^^^
```javascript
db.t.find(
    {"a": { $exists: true}
    }
)
```
Cette requ√™te renvera donc les documents ayant le sous-document `a` existant.

Enfin, l'op√©rateur `$size` permet des r√©cuperer les documents avec des sous-documents d'une certaine taille. Sa syntaxe en MongoDB s'√©crit comme suit :

MongoDB
^^^
```javascript
db.t.find(
    {"a": { $size: 5}
    }
)
```

 Le r√©sultat obtenu est l'ensemble des documents avec le sous-document `a` qui est de taille **5**.

### Op√©rateurs logiques

Les diff√©rents op√©rateurs logiques en MongoDB sont : `and`, `or` et `nor`. Ces op√©rateurs de tester plusieurs conditions simultan√©ment

#### `and` logique

L'op√©rateur `and` renvoie les documents qui remplissent l'ensemble des conditions. Pour faire une requ√™te avec un `and` logique en MongoDB, il suffit de s√©parer par une virgule chaque condition. L'exemple ci-dessous nous montre l'√©quivalence entre MongoDB et le langage SQL : 

````{panels}

MongoDB
^^^
```javascript
db.t.find(
    {"a": 1, "b": 5}
)
```

---

SQL
^^^
```sql
SELECT *
FROM t
WHERE a = 1 and b = 5
```

````

Le r√©sultat de la requ√™te sera les documents validant les deux conditions suivantes : `a` = **1** et `b` = **5**.

#### `or` logique

L'op√©rateur `or` permet de renvoyer les documents qui remplissent au moins un des conditions de la requ√™te. Le `or` logique se construit de la mani√®re suivane : `$or : [{condition 1}, ... , {condition i}]`. Voici un exemple faisant le parral√®le entre le langage MongoDB et le langage SQL :

````{panels}

MongoDB
^^^
```javascript
db.t.find(
    {$or : [
      {"a": 1},
      {"b": 5}
      ]
    }
)
```

---

SQL
^^^
```sql
SELECT *
FROM t
WHERE a = 1 or b = 5
```

````

Le r√©sultat de la requ√™te sera les documents validant au moins un des deux conditions suivantes : `a` = **1** ou `b` = **5**.

#### `nor` logique

L'op√©rateur `nor` permet de renvoyer les documents ne validant pas une liste de condition(s). Voici sa syntaxe qui est tr√®s semblable √† celle de `or` : 


MongoDB
^^^
```javascript
db.t.find(
    {$nor : [
      {"a": 1},
      {"b": "blue"}
      ]
    }
)
```
Le r√©sultat de cette requ√™te sera l'ensemble des documents ne contenant pas la valeur **1** pour la variable `a` et **"blue"** pour la variable `b`.

---

## M√©thodes utiles pour des requ√™tes en MongoDB

### Valeurs distinctes d'un champ : la m√©thode `distinct`

L'op√©rateur `distinct` permet ne renvoyer que les valeurs distinctes d'un champ ou d'une liste de conditions. C'est l'√©quivalent du `DISTINCT` en SQL.

````{panels}

MongoDB
^^^
```javascript
db.nomDeLaCollection.distinct(
    {"b": true}
)
```

---

Notation SQL
^^^
```sql
SELECT DISTINCT(b)
FROM nomDeLaCollection
```

````

La requ√™te ci-dessus permet de renvoyer tous les √©l√©ments distincts de `b` de la collection choisie. Si elle est bien formul√©e, on devrait obtenir tous les valeurs possibles du champ une fois au maximum.

### Conna√Ætre le nombre de documents dans une collection : la m√©thode `count`

La fonction `count` permet de compter le nombre d'√©l√©ments ou de documents pr√©sents dans une collection. On peut l'utiliser directement sur la collection de base ou bien l'utiliser apr√®s avoir ex√©cuter une requ√™te.

````{tabbed} Sur une collection sans requ√™te

```javascript
db.nomDeLaCollection.count()
```
````

````{tabbed} Sur une collection apr√®s requ√™te

```javascript
db.nomDeLaCollection.find({"a": 1}).count()
```
````

Bien entendu, les r√©sultats seront diff√©rents car on n'a pas le m√™me nombre de documents ou d'√©l√©ments avant et apr√®s une requ√™te.

### Trier la r√©cup√©ration des documents : la m√©thode `sort`

### Limiter la r√©cup√©ration des documents : la m√©thode `limit`
