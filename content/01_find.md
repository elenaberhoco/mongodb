---
jupytext:
  cell_metadata_filter: -all
  formats: md:myst
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.12
    jupytext_version: 1.9.1
kernelspec:
  display_name: IMongo
  language: ''
  name: imongo
---

# Premi√®res requ√™tes en MongoDB

Auteurs/trices : **Julie FRANCOISE, Manon MAHEO et Valentin PENISSON**

## Introduction √† MongoDB

Dans un **syst√®me de base de donn√©es relationnelles**, les donn√©es sont stock√©es par ligne *(appel√©es n-uplets)* dans des tables *(√©galement appel√©es relations)*. Le mod√®le de donn√©es relationnel est un mod√®le tr√®s structur√©, comportant des attributs typ√©s et des contraintes d'int√©grit√© *(comme par exemple l'unicit√© des valeurs de la cl√© primaire)*. Il est n√©cessaire de faire des jointures sur plusieurs tables afin de tirer des informations pertinentes de la base.

**Dans MongoDB, les donn√©es sont mod√©lis√©es sous forme de document sous un style JSON.** On ne parle plus de tables, ni d'enregistrements mais de collections et de documents. Une collection est un ensemble de documents, c'est l'√©quivalent d'une table en relationnel. Un document est un enregistrement, une ligne dans le mod√®le de donn√©es relationnel. Ce syst√®me de gestion de donn√©es nous √©vite de faire des jointures de tables car toutes les informations n√©cessaires sont stock√©es dans un m√™me document.

Tout document appartient √† une collection et a un champ appel√© "_id" qui identifie le document dans la base de donn√©es. Prenons la la base de donn√©es √©tudiants. Voici un exemple de document : 

```javascript
{
    "_id" : ObjectId("56011920de43611b917d773d"),
    "nom" : "Paul",
    "notes" : [ 
        10.0, 
        12.0
    ],
    "sexe" : "M"
}
```

On a une association de cl√©s et de valeurs, un document est √©quivalent aux objets JSON. Dans ce document, on a acc√®s au nom de l'√©tudiant, √† ses notes *(c'est une **liste de valeurs**, ce type d'attribut n'√©tant pas disponible dans le mod√®le relationnel)*, et √† son sexe. L'√©tudiant repr√©sent√© par ce document, est identifi√© √† l'aide d'une cl√© "_id". Pour effectuer des requ√™tes sur une base de donn√©es MongoDB et filtrer les donn√©es, il est indispensable d'utiliser ces indications cl√©s et valeurs. 

Dans ce chapitre, nous √©tudierons dans un premier temps [**comment interroger les donn√©es d'une base de donn√©es MongoDB avec la fonction find**](#find). Ensuite nous regarderons comment effectuer des [requ√™tes plus complexes, impliquant des **op√©rateurs de comparaison**](#operateurs). Quelques [**m√©thodes utiles**](#methodes) pour des requ√™tes en MongoDB sont donn√©es √† la fin de ce chapitre ainsi qu'une [**conclusion**](conclusion).

---

(find) = 
## Requ√™tes d'interrogation et de filtrage des donn√©es : la fonction `find`

Pour r√©cup√©rer des documents stock√©s dans une collection, il est n√©cessaire d'utiliser la fonction find.
 
 ```{admonition} Remarque
Toute commande sur une collection intitul√©e collectionName utilise le pr√©fixe db : "db.collectionName". Il suffit d‚Äôy associer la fonction souhait√©e pour avoir un r√©sultat. 

En l'occurence, ici la syntaxe de donn√©es d'interrogation MongoDB est db.collectionName.find().
```

En MongoDB, il existe deux types de requ√™tes simples, retournant respectivement **toutes les occurences d'une collection** ou **seulement la premi√®re**. 

````{panels}

Retourner toutes les occurences 
d'une collection avec find()
^^^
```javascript
 db.collectionName.find()
 db.collectionName.find({}) 
```

---

Retourner uniquement la premi√®re occurence
de la liste de r√©sultats avec findOne()
^^^
```javascript
db.collectionName.findOne()
db.collectionName.findOne({})
```

````

> √Ä noter : Dans les deuxi√®mes propositions, on a des accolades entre les parenth√®ses de la fonction. Ces accolades correspondent au *document masque*. Elles sont vides ce qui indique que nous ne posons pas de condition sur les documents √† retourner. 

Si l‚Äôon souhaite fixer des contraintes sur les documents √† retourner, il suffit de passer en argument d‚Äôune de ces fonctions un document masque contenant les valeurs souhait√©es. La requ√™te suivante retourne tous les documents ayant un champ "x" dont la valeur est "y". En utilisant cette syntaxe, on recherche par exemple les documents de la collection NYfood correspondant √† des **boulangeries** *(pour lesquels le champ "cuisine" vaut "Bakery")* **du Bronx** *(pour lesquels le champ "borough" vaut "Bronx")*. Dans cet exemple sur la base de donn√©es NYfood, la virgule repr√©sente un ET logique entre les contraintes.     

````{tabbed} Syntaxe

```javascript
db.nomDeLaCollection.find({"x":"y"})
```

````
 
````{tabbed} Exemple sur la base de donn√©es NYfood

```javascript
db.NYfood.find(
    {"cuisine": "Chinese", "borough": "Bronx"}
)
```

````

Il se peut que pour une cl√© d'un document, comme par exemple l'adresse d'un restaurant, nous disposons d'un **sous-document** contenant √† la fois les coordonn√©es GPS et l'adresse postale. Si l'on souhaite **poser une condition sur une cl√© ou plusieurs cl√©s de sous-document**, on utilise alors la syntaxe suivante :

```javascript
db.NYfood.find({"adress.zipcode": "10462"})
```
o√π adress est le sous-document et zipcode la cl√© de ce dernier. Dans cet exemple, nous nous int√©ressons aux restaurants pour lesquels le zipcode est "10462".

Les r√©sultats que obtenus jusqu‚Äô√† pr√©sent sont parfois assez indigestes, notamment parce que toutes les cl√©s sont retourn√©es pour tous les documents. Il est possible de limiter cela en sp√©cifiant les cl√©s √† retourner comme second argument de find(). On appelle √ßa une **projection**.

<dl>
  <dt>Projection</dt>
  <dd>La projection permet de s√©lectionner les informations √† renvoyer. Si, par exemple, je m‚Äôint√©resse uniquement aux noms des boulangeries du Bronx, je vais     limiter les informations retourn√©es en pr√©cisant comme deuxi√®me argument de ma recherche find, la cl√© name avec la valeur true.</dd>
</dl>

```javascript
db.NYfood.find({"cuisine": "Bakery", "borough": "Bronx"}, {"name": true})
```
> C'est l'√©quivalent du "SELECT name" en SQL. Jusqu'ici, on utilisais le "SELECT *" *(pour all)* c'est-√†-dire qu'on r√©cup√©rait toutes les valeurs de chaque cl√© ou de chaque attribut.

```{admonition} Embellissez les r√©sultats de la fonction find ! 
:class: tip

Les r√©sultats de la fonction find() peuvent appara√Ætre d√©sorganis√©s. MongoDB fournit pretty() qui affiche les r√©sultats sous une forme plus lisible. La syntaxe est la suivante : collectionName.find().pretty() üòâ
```

Pour plus de renseignements sur la **fonction find()**, consultez la documentation MongoDB [disponible ici](https://docs.mongodb.com/manual/reference/method/db.collection.find/).

---

(operateurs)= 
## Requ√™tes plus complexes en utilisant des op√©rateurs

Les op√©rateurs se s√©parent en deux grandes parties : les **op√©rateurs de comparaison** et les **op√©rateurs logiques**.

### Op√©rateurs de comparaison

L'op√©rateur de comparaison permet de comparer deux √©lements entre eux. Le tableau suivant l'ensemble des op√©rateurs de comparaison : 

| Op√©rateur logique 	| Mot cl√© en MongoDB 	|
|-	|-	|
| = 	| $eq 	|
| < 	| $lt 	|
| > 	| $gt 	|
| ‚â§ 	| $lte 	|
| ‚â• 	| $gte 	|
| ‚àà 	| $in 	|
| ‚àâ 	| $nin 	|
| n√©gation 	| $ne 	|
| cl√© existante 	| $exists 	|
| \|.\| 	| $size 	|

Les op√©rateurs `$eq`, `$lt`, `$gt`, `$lte`, `$gte` s'utilisent de la m√™me fa√ßon en MongoDB. Ces op√©rateurs comparent la valeur d'une variable √† une valeur fixe (nombre, bool√©en, chaine de caract√®res...).

````{panels}

MongoDB
^^^
```javascript
db.t.find(
    {"a": {$gte : 1}
    }
)
```

---

SQL
^^^
```sql
SELECT *
FROM t
WHERE a >= 1 
```

````

Les op√©rateurs `$in` et `$nin` s'ulisent de la m√™me fa√ßon en MongoDB. Ces op√©rateurs teste l'existence de la valeur d'une variable dans une liste. Sa fa√ßon de l'utiliser en MongoDB est la suivante : 

````{panels}

MongoDB
^^^
```javascript
db.t.find(
    {"a": { $in: ["chaine1", "chaine2"] }
    }
)
```

---

SQL
^^^
```sql
SELECT *
FROM t
WHERE a IN ("chaine1", "chaine2")
```

````

L'op√©rateur `$exists` v√©rifie l'existence d'une cl√© dans un document. Sa syntaxe en MongoDB est : 

```javascript
db.t.find(
    {"a": { $exists: true}
    }
)
```
Cette requ√™te renvera donc les documents ayant le sous-document `a` existant.

Enfin, l'op√©rateur `$size` permet des r√©cuperer les documents avec des sous-documents d'une certaine taille. Sa syntaxe en MongoDB s'√©crit comme suit :

```javascript
db.t.find(
    {"a": { $size: 5}
    }
)
```
Le r√©sultat obtenu est l'ensemble des documents avec le sous-document `a` qui est de taille **5**.

### Op√©rateurs logiques

Les diff√©rents op√©rateurs logiques en MongoDB sont : `and`, `or`, `not` et `nor`. Ces op√©rateurs de tester plusieurs conditions simultan√©ment.

#### `and` logique

L'op√©rateur `and` renvoie les documents qui remplissent l'ensemble des conditions. Pour faire une requ√™te avec un `and` logique en MongoDB, il suffit de s√©parer par une virgule chaque condition. L'exemple ci-dessous nous montre l'√©quivalence entre MongoDB et le langage SQL : 

````{panels}

MongoDB
^^^
```javascript
db.t.find(
    {"a": 1, "b": 5}
)
```

---

SQL
^^^
```sql
SELECT *
FROM t
WHERE a = 1 and b = 5
```

````

Le r√©sultat de la requ√™te sera les documents validant les deux conditions suivantes : `a` = **1** et `b` = **5**.

#### `or` logique

L'op√©rateur `or` permet de renvoyer les documents qui remplissent au moins un des conditions de la requ√™te. Le `or` logique se construit de la mani√®re suivane : `$or : [{condition 1}, ... , {condition i}]`. Voici un exemple faisant le parral√®le entre le langage MongoDB et le langage SQL :

````{panels}

MongoDB
^^^
```javascript
db.t.find(
    {$or : [
      {"a": 1},
      {"b": 5}
      ]
    }
)
```

---

SQL
^^^
```sql
SELECT *
FROM t
WHERE a = 1 or b = 5
```

````

Le r√©sultat de la requ√™te sera les documents validant au moins un des deux conditions suivantes : `a` = **1** ou `b` = **5**.

#### `nor` logique

L'op√©rateur `nor` permet de renvoyer les documents ne validant pas une liste de condition(s). Voici sa syntaxe qui est tr√®s semblable √† celle de `or` : 

```javascript
db.t.find(
    {$nor : [
      {"a": 1},
      {"b": "blue"}
      ]
    }
)
```
Le r√©sultat de cette requ√™te sera l'ensemble des documents ne contenant pas la valeur **1** pour la variable `a` et **"blue"** pour la variable `b`.

https://docs.mongodb.com/manual/reference/operator/query/

---

(methodes) =
## M√©thodes utiles pour des requ√™tes en MongoDB

### Valeurs distinctes d'un champ : la m√©thode `distinct`

La m√©thode `distinct` permet de ne renvoyer que les valeurs distinctes d'un champ ou d'une liste de conditions. C'est l'√©quivalent du `DISTINCT` en SQL.

````{panels}

MongoDB
^^^
```javascript
db.collectionName.distinct(champ,
    {...}
)
```

---

Notation SQL
^^^
```sql
SELECT DISTINCT(champ)
FROM collectionName
WHERE ...
```

````

La requ√™te ci-dessus permet de renvoyer tous les √©l√©ments distincts de `champ` de la collection choisie. Si elle est bien formul√©e, on devrait obtenir tous les valeurs possibles du champ une fois au maximum.

### Compter le nombre d'√©l√©ments : la m√©thode `count`

La m√©thode `count` permet de compter le nombre d'√©l√©ments ou de documents pr√©sents dans une collection. On peut l'utiliser directement sur la collection de base ou bien l'utiliser apr√®s avoir ex√©cuter une requ√™te.

````{tabbed} Sur une collection sans requ√™te

```javascript
db.collectionName.count()
```
````

````{tabbed} Sur une collection apr√®s requ√™te

```javascript
db.collectionName.find({"a": 1}).count()
```
````

Bien entendu, les r√©sultats seront diff√©rents car on n'a pas le m√™me nombre de documents ou d'√©l√©ments avant et apr√®s une requ√™te.

### Trier la r√©cup√©ration des documents : la m√©thode `sort`

La m√©thode `sort` sert √† trier, apr√®s avoir effectuer une requ√™te, les documents ou les √©l√©ments de la base de donn√©es √† partir d'un des champs. Pour choisir l'ordre, il suffit de mettre `1` pour trier dans un ordre croissant et `-1` pour trier dans un ordre d√©croissant.

Voici comme √ßa se pr√©sente pour un tri par ordre croissant.
```javascript
db.collectionName.find().sort(
  {"champ" : 1}
)
```

Il est √©galement possible de faire un tri sur plusieurs champs. On peut aussi mettre diff√©rents ordres, croissant ou d√©ccroissant.
```javascript
db.collectionName.find().sort(
  {"champ1" : 1, "champ2" : -1}
)
```

On notera qu'il est impossible d'utiliser cette m√©thode sans faire une requ√™te `find` au pr√©alable qu'elle soit vide ou non.

### Limiter la r√©cup√©ration des documents : la m√©thode `limit`

On √©galement limiter le nombre de r√©sultats obtenus avec la m√©thode limit.

```javascript
db.NYfood.find({}).limit(2)
```

---

(conclusion) = 
## Conclusion

